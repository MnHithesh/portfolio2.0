<div class="dialog-header">
  <h2>Building a Portfolio That Supports Angular & React</h2>
  <button class="close" (click)="close()">‚úï</button>
</div>
<mat-dialog-content class="mat-typography">
  <section>
    <h3 style="color: #ffffff">Overview</h3>
    <p style="color: #ffffff">
      Instead of choosing a single framework for my portfolio, I wanted to demonstrate how I think
      as a frontend engineer, not just what I code in. This led me to design the portfolio as a
      shell-based system where Angular and React coexist cleanly.
    </p>
  </section>

  <section>
    <h3 style="color: #ffffff">üß© Problem</h3>
    <p style="color: #ffffff">I wanted my portfolio to:</p>
    <ul style="color: #ffffff">
      <li>Showcase both Angular and React</li>
      <li>Avoid duplicating UI or maintaining two separate sites</li>
      <li>Keep frameworks independent, not mixed</li>
      <li>Reflect real-world frontend architecture, not demos</li>
    </ul>
    <p style="color: #ffffff">
      Using iframes or separate deployments felt like shortcuts and didn‚Äôt align with how large
      frontend systems are built.
    </p>
  </section>

  <section>
    <h3 style="color: #ffffff">üéØ Goal</h3>
    <p style="color: #ffffff">Create a single portfolio experience that:</p>
    <ul style="color: #ffffff">
      <li>Uses Angular for structure and navigation</li>
      <li>Loads React only when needed</li>
      <li>Keeps ownership and lifecycle explicit</li>
      <li>Is scalable and explainable in interviews</li>
    </ul>
  </section>

  <section>
    <h3 style="color: #ffffff">üèóÔ∏è Solution</h3>
    <p style="color: #ffffff">
      I implemented a Micro-Frontend architecture using Module Federation:
    </p>
    <ul style="color: #ffffff">
      <li>Angular ‚Üí Host / Shell</li>
      <li>React (Vite) ‚Üí Remote / Micro-frontend</li>
    </ul>
    <p style="color: #ffffff">
      React is loaded at runtime, only when the user navigates to the React section of the
      portfolio. This keeps both frameworks:
    </p>
    <ul style="color: #ffffff">
      <li>Framework-native</li>
      <li>Independently built</li>
      <li>Independently reasoned about</li>
    </ul>
  </section>

  <section>
    <h3 style="color: #ffffff">üß† Key Architectural Decisions</h3>
    <p style="color: #ffffff">1. Angular as the Shell</p>
    <ul style="color: #ffffff">
      <li>Routing</li>
      <li>Layout</li>
      <li>Navigation</li>
      <li>Lifecycle control</li>
    </ul>
    <p style="color: #ffffff">
      This aligns with Angular‚Äôs strengths in structure and orchestration.
    </p>

    <p style="color: #ffffff">2. React as a Remote</p>
    <ul style="color: #ffffff">
      <li>Exposes explicit mount and unmount functions</li>
      <li>Does not auto-render</li>
      <li>The host decides when and where it appears</li>
    </ul>

    <p style="color: #ffffff">3. Explicit Lifecycle Control</p>
    <ul style="color: #ffffff">
      <li>Angular mounts React when entering the route</li>
      <li>Angular unmounts React on navigation</li>
    </ul>
    <p style="color: #ffffff">This prevents memory leaks and keeps ownership clear.</p>

    <p style="color: #ffffff">4. Contract-Based Communication</p>
    <ul style="color: #ffffff">
      <li>Data flows Angular ‚Üí React via explicit props</li>
      <li>No shared global state</li>
      <li>No cross-framework imports</li>
    </ul>
    <p style="color: #ffffff">This keeps the boundary clean and predictable.</p>
  </section>

  <section>
    <h3 style="color: #ffffff">‚ö†Ô∏è Challenges & Learnings</h3>
    <p style="color: #ffffff">Tooling Mismatch</p>
    <ul style="color: #ffffff">
      <li>Angular uses Webpack</li>
      <li>React uses Vite (ESM)</li>
    </ul>
    <p style="color: #ffffff">This required understanding:</p>
    <ul style="color: #ffffff">
      <li>ESM vs script loading</li>
      <li>Correct Module Federation configuration</li>
      <li>Runtime behavior vs dev assumptions</li>
    </ul>
  </section>

  <section>
    <h3 style="color: #ffffff">Runtime Debugging</h3>
    <p style="color: #ffffff">Several issues appeared only at runtime:</p>
    <ul style="color: #ffffff">
      <li>Remote not loading due to port mismatch</li>
      <li>Exposed file not matching the expected contract</li>
      <li>Lifecycle functions unavailable due to incorrect exposure</li>
    </ul>
    <p style="color: #ffffff">
      Key lesson: Micro-frontends fail more often due to environment alignment than conceptual
      mistakes.
    </p>
  </section>

  <section>
    <h3 style="color: #ffffff">‚úÖ Outcome</h3>
    <ul style="color: #ffffff">
      <li>Angular and React coexist cleanly</li>
      <li>React loads only when required</li>
      <li>Lifecycle and data flow are explicit</li>
      <li>Portfolio reflects architectural thinking, not just UI skills</li>
    </ul>
    <p style="color: #ffffff">
      Key lesson: Micro-frontends fail more often due to environment alignment than conceptual
      mistakes.
    </p>
  </section>
  <section>
    <h3 style="color: #ffffff">Summary</h3>
    <p style="color: #ffffff">
      Designed a portfolio using Angular as a shell and React as a micro-frontend via Module
      Federation, focusing on runtime loading, lifecycle control, and clean framework boundaries.
    </p>
  </section>
</mat-dialog-content>
<mat-dialog-actions align="end">
  <!-- <button matButton mat-dialog-close>Cancel</button>
  <button matButton [mat-dialog-close]="true" cdkFocusInitial>Install</button> -->
</mat-dialog-actions>
